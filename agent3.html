<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent 3 — Trust Law (BM25 index)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="icon" href="logo.png">
  <link rel="stylesheet" href="brand.css">
  <link rel="stylesheet" href="agent3.css">
  <style>
    /* light touch: ensure visible even if some old CSS lingers */
    .card{opacity:1!important;filter:none!important}
  </style>
</head>
<body>
  <header class="header">
    <div class="wrap">
      <img src="logo.png" alt="WWBCB">
      <div class="brand">Agent 3 — Trust Law <small>(BM25 index)</small></div>
    </div>
  </header>

  <main class="main">
    <form class="searchbar" id="searchForm">
      <input id="q" type="text"
             placeholder="e.g., beddoe consent litigation, Saunders v Vautier, JTL 1984 s 5, trustee proper law">
      <label title="Return results if ANY term matches">
        <input id="orMode" type="checkbox"> OR mode
      </label>
      <button class="btn" type="submit">Search</button>
    </form>

    <p class="note">
      Searches <strong>all TXT</strong> listed in the catalogs on <em>texts.wwwbcb.org</em>. Results are chunk-level
      BM25/Lunr matches with source links. No model inference; no hallucinations.
    </p>

    <div id="results" class="results"></div>
    <div id="diag" class="diagnostics" style="display:none"></div>
  </main>

  <script src="https://unpkg.com/lunr@2.3.9/lunr.min.js"></script>
  <script>
  (function(){
    // ---------- CONFIG / FALLBACKS ----------
    const INDEX_CANDIDATES = [
      'https://texts.wwwbcb.org/agent3-bm25/agent3.json',
      'https://texts.wwwbcb.org/agent3/agent3.json'
    ];
    const DOCS_CANDIDATES = [
      'https://texts.wwwbcb.org/agent3-bm25/docs.json',
      'https://texts.wwwbcb.org/agent3/docs.json'
    ];

    const els = {
      form: document.getElementById('searchForm'),
      q:    document.getElementById('q'),
      or:   document.getElementById('orMode'),
      out:  document.getElementById('results'),
      diag: document.getElementById('diag')
    };

    let idx = null;                 // lunr.Index
    let docs = [];                  // [{id,title,kind,jurisdiction,text,url}]
    let byId = Object.create(null);
    let pending = null;             // {q, or} to auto-run when ready

    // ------------- helpers -------------
    const esc = s => (s+'')
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;').replace(/'/g,'&#39;');

    function mark(txt, terms){
      let out = esc(txt);
      for (const t of terms){
        if(!t) continue;
        const safe = t.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
        out = out.replace(new RegExp(`(${safe})`,'gi'), '<mark>$1</mark>');
      }
      return out;
    }

    function snippet(full, terms, radius=560){
      if (!full) return '';
      const lower = full.toLowerCase();
      let pos = -1;
      for (const t of terms){
        if(!t) continue;
        const p = lower.indexOf(t.toLowerCase());
        if (p >= 0 && (pos < 0 || p < pos)) pos = p;
      }
      if (pos < 0) pos = 0;
      let start = Math.max(0, pos - Math.floor(radius/2));
      let end   = Math.min(full.length, start + radius);
      if (end - start < radius && start > 0) start = Math.max(0, end - radius);
      const slice = full.slice(start, end);
      return (start>0?'…':'') + mark(slice, terms) + (end<full.length?'…':'');
    }

    function cardHTML(hit){
      const d = byId[hit.ref] || {};
      const title = d.title || 'Untitled';
      const kind  = d.kind || 'textbook';
      const jur   = d.jurisdiction || '';
      const url   = d.url || d.href || '#';
      const text  = d.text || '';
      const terms = (els.q.value||'').trim().split(/\s+/).filter(Boolean);
      const snip  = snippet(text, terms, 560);
      return `
        <article class="card">
          <div class="meta">
            <span class="pill">${esc(kind)}</span>
            ${jur?`<span class="pill">${esc(jur)}</span>`:''}
            <a class="open" href="${esc(url)}" target="_blank" rel="noopener">open&nbsp;TXT</a>
          </div>
          <div class="title">${esc(title)}</div>
          <div class="snippet">${snip}</div>
        </article>`;
    }

    function render(results, diagText){
      const list = Array.isArray(results) ? results : [];
      if (list.length === 0){
        els.out.innerHTML = `<article class="card"><div class="snippet">No matches.</div></article>`;
      } else {
        els.out.innerHTML = list.map(cardHTML).join('');
      }
      els.out.querySelectorAll('.card').forEach(el => { el.style.opacity=1; el.style.filter='none'; });

      if (diagText){
        els.diag.style.display='block';
        els.diag.textContent = diagText;
      } else {
        els.diag.style.display='none';
        els.diag.textContent = '';
      }
      document.body.classList.remove('loading');
    }

    function buildQuery(raw, orMode){
      raw = (raw||'').trim();
      if (!raw) return '';
      const parts = raw.split(/\s+/).filter(Boolean);
      return orMode ? parts.join(' ') : parts.map(t => (t.startsWith('+')?t:`+${t}`)).join(' ');
    }

    function doSearch(ev){
      if (ev) ev.preventDefault();
      const raw = els.q.value || '';
      const or  = !!els.or.checked;
      if (!idx){
        pending = { q: raw, or };
        render([], 'Index loading…');
        return;
      }
      const q = buildQuery(raw, or);
      if (!q){ render([], 'Enter one or more terms.'); return; }
      let hits = [];
      try { hits = idx.search(q); }
      catch(e){ render([], `Query error: ${e && e.message ? e.message : e}`); return; }
      const diag = `Docs: ${docs.length} · Query: ${raw} · OR=${or} · Hits: ${hits.length}`;
      render(hits.slice(0, 200), diag);
    }

    els.form.addEventListener('submit', doSearch);
    els.q.addEventListener('keydown', e=>{
      if (e.key==='Enter' && (e.metaKey||e.ctrlKey||e.shiftKey)){
        els.or.checked = !els.or.checked; e.preventDefault();
      }
    });

    // --------- load index + docs with fallback ---------
    async function fetchFirstGood(urls){
      const errs = [];
      for (const u of urls){
        try{
          const r = await fetch(u, { cache:'no-store' });
          if (!r.ok) { errs.push(`${u} → ${r.status}`); continue; }
          return await r.json();
        }catch(ex){ errs.push(`${u} → ${ex}`); }
      }
      throw new Error(errs.join(' | '));
    }

    (async function init(){
      document.body.classList.add('loading');
      try{
        const [idxJson, docsJson] = await Promise.all([
          fetchFirstGood(INDEX_CANDIDATES),
          fetchFirstGood(DOCS_CANDIDATES)
        ]);
        idx  = lunr.Index.load(idxJson);
        docs = Array.isArray(docsJson) ? docsJson : (docsJson.docs || []);
        byId = Object.fromEntries(docs.map(d => [String(d.id ?? d.ref ?? d.doc ?? d.i), d]));
        // auto-run any query that was submitted before load finished
        const msg = `Loaded index (${docs.length} docs).`;
        if (pending && (pending.q||'').trim()){
          els.q.value = pending.q;
          els.or.checked = !!pending.or;
          const saved = pending; pending = null;
          const q = buildQuery(saved.q, saved.or);
          try{
            const hits = idx.search(q);
            render(hits.slice(0,200), `${msg} · Auto-searched.`);
          }catch(e){
            render([], `${msg} · Query error: ${e && e.message ? e.message : e}`);
          }
        } else {
          render([], msg);
        }
      }catch(err){
        render([], `Failed to load index/docs: ${err && err.message ? err.message : err}`);
      }
    })();
  })();
  </script>
</body>
</html>
