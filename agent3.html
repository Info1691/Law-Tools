<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Agent 3 — Trust Law (BM25 index)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="brand.css" rel="stylesheet" />
  <style>
    body { max-width: 1100px; margin: 24px auto; padding: 0 16px; }
    .bar { display:flex; gap:8px; align-items:center; }
    input[type=text]{ flex:1; padding:10px 12px; border-radius:8px; border:1px solid #333; background:#0d1117; color:#eee; }
    button{ padding:10px 14px; border-radius:8px; border:1px solid #333; background:#1f6feb; color:white; }
    button[disabled]{ opacity:.6; cursor:not-allowed; }
    .meta{ opacity:.75; font-size:.9rem; }
    .hit{ background:#0f1724; border:1px solid #223; border-radius:12px; padding:14px; margin:14px 0; }
    .title{ font-weight:600; }
    mark{ background:#444; padding:0 .15rem; border-radius:3px; }
    .diag{ background:#0a0f17; border:1px dashed #2a2f3a; border-radius:10px; padding:10px; margin-top:14px; white-space:pre-wrap; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js"></script>
</head>
<body>
  <h1>Agent 3 — Trust Law (BM25 index)</h1>
  <div class="bar">
    <input id="q" type="text" placeholder='beddoe consent litigation, Saunders v Vautier, JTL 1984 s 5, trustee proper law' />
    <label class="meta"><input id="or" type="checkbox"> OR mode</label>
    <button id="go" disabled>Search</button>
  </div>

  <p class="meta">Searches <em>all</em> TXT listed in the catalogs on <code>texts.wwwbcb.org</code>. Results are chunk-level BM25 matches with source links. No model inference; no hallucinations.</p>

  <div id="out" class="meta">Loading index…</div>
  <div id="diag" class="diag" style="display:none"></div>

<script>
const DIAG = document.getElementById('diag');
const OUT  = document.getElementById('out');
const GO   = document.getElementById('go');
const ORCB = document.getElementById('or');
const Q    = document.getElementById('q');

// Try both locations; use whichever responds
const CANDIDATES = [
  'https://texts.wwwbcb.org/data/agent3/',
  '/data/agent3/'
];

let BASE = null;
let idx = null;
let chunks = new Map(); // id -> {id,src,title,kind,juris,url,offset,text}

function showDiag(s){ DIAG.style.display='block'; DIAG.textContent = String(s); }
function appendDiag(s){ DIAG.style.display='block'; DIAG.textContent += '\n' + String(s); }
function esc(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

async function headOk(url){
  try{
    const res = await fetch(url, { method:'GET', cache:'no-store' });
    return res.ok;
  }catch(e){ return false; }
}

async function pickBase(){
  for (const base of CANDIDATES){
    if (await headOk(base + 'lunr-index.json')) return base;
  }
  return null;
}

function clean(s){
  return s
    .replace(/^\uFEFF/, '')
    .replace(/\u00A0/g,' ')
    .replace(/\u200B/g,'')
    .replace(/\r\n/g,'\n');
}

async function loadIndex(){
  BASE = await pickBase();
  if(!BASE){
    showDiag('Index not found. Run the “agent3-bm25” workflow to generate data/agent3/{lunr-index.json,chunks.jsonl} in Law-Texts-ui, then reload.');
    OUT.textContent = 'Index not found.';
    return;
  }

  showDiag(`Using base: ${BASE}\nFetching index…`);
  const [idxRes, chRes] = await Promise.all([
    fetch(BASE + 'lunr-index.json', { cache:'no-store' }),
    fetch(BASE + 'chunks.jsonl',    { cache:'no-store' })
  ]);

  if(!idxRes.ok || !chRes.ok){
    showDiag(`Fetch failed.\nindex: ${idxRes.status}\nchunks: ${chRes.status}`);
    OUT.textContent = 'Failed to load index.';
    return;
  }

  // Avoid streaming (iPad Safari can null body for cross-origin). Read as text.
  const [idxJson, chunksText] = await Promise.all([idxRes.json(), chRes.text()]);
  idx = lunr.Index.load(idxJson);

  let n=0;
  for (const line of chunksText.split('\n')){
    if(!line.trim()) continue;
    try{
      const obj = JSON.parse(line);
      obj.text = clean(obj.text);
      chunks.set(obj.id, obj);
      n++;
    }catch(e){
      // skip bad line, but record for debugging
      appendDiag('Bad JSONL line skipped.');
    }
  }

  OUT.textContent = `Index loaded (${n} chunks). Enter a query.`;
  GO.disabled = false;
}

function termsFrom(q){
  const terms = [];
  const ph = /"([^"]+)"/g; let m;
  while((m = ph.exec(q))) terms.push(m[1]);
  q = q.replace(ph,' ').trim();
  for (const t of q.split(/\s+/).filter(Boolean)) terms.push(t);
  return [...new Set(terms)];
}

function search(query, orMode){
  if(!idx || !query.trim()) return [];
  const t = termsFrom(query);
  const clauses = t.map(x=>x);
  const andQ = clauses.map(c => '+'+c).join(' ');
  const orQ  = clauses.join(' ');
  let res = [];
  try{
    res = idx.search(orMode ? orQ : andQ);
  }catch(e){
    appendDiag('Search parse error: '+e.message);
    // fall back to OR
    try { res = idx.search(orQ); } catch(_) {}
  }
  return res.map(r => ({ score:r.score, ...chunks.get(r.ref) })).filter(Boolean);
}

function highlight(txt, terms){
  let s = esc(txt);
  const sorted = [...terms].sort((a,b)=>b.length-a.length);
  for (const t of sorted){
    const re = new RegExp('('+t.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')+')','ig');
    s = s.replace(re,'<mark>$1</mark>');
  }
  return s;
}

function render(hits, query){
  const t = termsFrom(query);
  if(!hits.length){
    OUT.innerHTML = `<p class="meta">No matches in the catalogs.</p>`;
    return;
  }
  const html = hits.slice(0,50).map(h=>{
    const snip = highlight(h.text.slice(0,600).replace(/\n/g,' '), t);
    return `
      <div class="hit">
        <div class="title">${esc(h.title)} <span class="meta">(${esc(h.kind)}${h.juris?'; '+esc(h.juris):''})</span></div>
        <div class="meta"><a href="${h.url}" target="_blank" rel="noopener">open TXT</a></div>
        <div style="margin-top:8px">${snip}</div>
      </div>
    `;
  }).join('');
  OUT.innerHTML = html;
}

GO.addEventListener('click', ()=>{
  const q = Q.value || '';
  const hits = search(q, ORCB.checked);
  render(hits, q);
});
Q.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !GO.disabled){ GO.click(); }});

// boot
loadIndex().catch(e=>{
  showDiag('Loader error: '+e.message);
  OUT.textContent = 'Failed to load index.';
});
</script>
</body>
</html>
