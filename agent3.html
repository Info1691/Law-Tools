<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent 3 — Trust Law (BM25 index)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="icon" href="logo.png">
  <link rel="stylesheet" href="brand.css">
  <link rel="stylesheet" href="agent3.css">
</head>
<body>
  <header class="header">
    <div class="wrap">
      <img src="logo.png" alt="WWBCB">
      <div class="brand">Agent 3 — Trust Law <small>(BM25 index)</small></div>
    </div>
  </header>

  <main class="main">
    <form class="searchbar" id="searchForm">
      <input id="q" type="text"
             placeholder="e.g., beddoe consent litigation, Saunders v Vautier, JTL 1984 s 5, trustee proper law">
      <label title="Return results if ANY term matches">
        <input id="orMode" type="checkbox"> OR mode
      </label>
      <button class="btn" type="submit">Search</button>
    </form>

    <p class="note">
      Searches <strong>all TXT</strong> listed in the catalogs on <em>texts.wwwbcb.org</em>. Results are chunk-level
      BM25/Lunr matches with source links. No model inference; no hallucinations.
    </p>

    <div id="results" class="results"></div>
    <div id="diag" class="diagnostics" style="display:none"></div>
  </main>

  <!-- Lunr (BM25-like) -->
  <script src="https://unpkg.com/lunr@2.3.9/lunr.min.js"></script>
  <script>
  (function(){
    // ====== CONFIG — change if your build outputs live elsewhere ======
    const INDEX_URL = 'https://texts.wwwbcb.org/agent3-bm25/agent3.json';
    const DOCS_URL  = 'https://texts.wwwbcb.org/agent3-bm25/docs.json';
    // ================================================================

    const els = {
      form: document.getElementById('searchForm'),
      q:    document.getElementById('q'),
      or:   document.getElementById('orMode'),
      out:  document.getElementById('results'),
      diag: document.getElementById('diag')
    };

    let idx = null;           // lunr.Index
    let docs = [];            // [{id,title,kind,jurisdiction,text,url}]
    let byId = Object.create(null);

    // Utility: escape HTML safely
    const esc = s => (s+'')
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;').replace(/'/g,'&#39;');

    // Utility: mark query terms
    function mark(txt, terms){
      let out = esc(txt);
      terms.forEach(t=>{
        if(!t) return;
        const safe = t.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
        out = out.replace(new RegExp(`(${safe})`,'gi'), '<mark>$1</mark>');
      });
      return out;
    }

    // Make a centered snippet around first match
    function snippet(full, terms, radius=220){
      const lower = full.toLowerCase();
      let pos = -1;
      for (const t of terms){
        if(!t) continue;
        const p = lower.indexOf(t.toLowerCase());
        if (p >= 0 && (pos < 0 || p < pos)) pos = p;
      }
      if (pos < 0) pos = 0;
      let start = Math.max(0, pos - Math.floor(radius/2));
      let end   = Math.min(full.length, start + radius);
      if (end - start < radius && start > 0) start = Math.max(0, end - radius);
      const slice = full.slice(start, end);
      return (start>0?'…':'') + mark(slice, terms) + (end<full.length?'…':'');
    }

    function cardHTML(hit){
      const d = byId[hit.ref] || {};
      const title = d.title || 'Untitled';
      const kind  = d.kind || 'textbook';
      const jur   = d.jurisdiction || '';
      const url   = d.url || d.href || '#';
      const text  = d.text || '';
      const terms = (els.q.value||'').trim().split(/\s+/).filter(Boolean);
      const snip  = snippet(text, terms, 560); // generous for readability

      return `
      <article class="card">
        <div class="meta">
          <span class="pill">${esc(kind)}</span>
          ${jur?`<span class="pill">${esc(jur)}</span>`:''}
          <a class="open" href="${esc(url)}" target="_blank" rel="noopener">open&nbsp;TXT</a>
        </div>
        <div class="title">${esc(title)}</div>
        <div class="snippet">${snip}</div>
      </article>`;
    }

    function render(results, diagText){
      if (!Array.isArray(results)) results = [];
      if (results.length === 0){
        els.out.innerHTML =
          `<article class="card"><div class="snippet">No matches.</div></article>`;
      } else {
        els.out.innerHTML = results.map(cardHTML).join('');
      }
      // ensure nothing stays faded from any legacy CSS/JS
      els.out.querySelectorAll('.card').forEach(el=>{
        el.style.opacity = 1; el.style.filter = 'none';
      });

      if (diagText){
        els.diag.style.display = 'block';
        els.diag.textContent = diagText;
      } else {
        els.diag.style.display = 'none';
        els.diag.textContent = '';
      }
      document.body.classList.remove('loading');
    }

    function buildQuery(raw, orMode){
      raw = (raw||'').trim();
      if (!raw) return '';
      const parts = raw.split(/\s+/).filter(Boolean);
      if (orMode) return parts.join(' ');
      // lunr AND: prefix each term with +
      return parts.map(t => (t.startsWith('+')?t:`+${t}`)).join(' ');
    }

    function doSearch(ev){
      if (ev) ev.preventDefault();
      if (!idx){ render([], 'Index loading…'); return; }
      const q = buildQuery(els.q.value, els.or.checked);
      if (!q){ render([], 'Enter one or more terms.'); return; }
      let hits = [];
      try {
        hits = idx.search(q);
      } catch (e){
        render([], `Query error: ${e.message || e}`);
        return;
      }
      // Diagnostics
      const diag = `Docs: ${docs.length} · Query: ${els.q.value} · OR=${!!els.or.checked} · Hits: ${hits.length}`;
      render(hits.slice(0, 200), diag); // cap to avoid massive DOMs
    }

    // Wire UI
    els.form.addEventListener('submit', doSearch);
    els.q.addEventListener('keydown', e => {
      if (e.key === 'Enter' && (e.metaKey || e.ctrlKey || e.shiftKey)) {
        els.or.checked = !els.or.checked;
        e.preventDefault();
      }
    });

    // Load index + docs
    document.body.classList.add('loading');
    Promise.all([ fetch(INDEX_URL).then(r=>r.json()), fetch(DOCS_URL).then(r=>r.json()) ])
      .then(([idxJson, docsJson])=>{
        idx = lunr.Index.load(idxJson);
        docs = Array.isArray(docsJson) ? docsJson : (docsJson.docs || []);
        byId = Object.fromEntries(docs.map(d => [String(d.id ?? d.ref ?? d.doc ?? d.i), d]));
        // first paint: no search yet
        render([], `Loaded index (${docs.length} docs).`);
      })
      .catch(err=>{
        render([], `Failed to load index/docs — ${err && err.message ? err.message : err}`);
      });
  })();
  </script>
</body>
</html>
